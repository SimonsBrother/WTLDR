""" Contains functionality and classes related to getting emails from an email account.
Highlights:
The Email dataclass, for representing key information about emails.
Functions for getting details from Message objects.
The EmailManager class, for handling interactions with an email account.
"""

import imaplib
import email
from email.message import Message
from email.header import decode_header
from dataclasses import dataclass
from datetime import datetime

# Dictionary generated by ChatGPT
month_name_to_number = {
    "January": 1,
    "February": 2,
    "March": 3,
    "April": 4,
    "May": 5,
    "June": 6,
    "July": 7,
    "August": 8,
    "September": 9,
    "October": 10,
    "November": 11,
    "December": 12
}


@dataclass
class Email:
    """ Dataclass for storing details about emails """
    email_id: int
    sender: str
    subject: str
    body: str
    time_sent: datetime

    def __repr__(self):
        return (f"Email(email_id={self.email_id}, sender='{self.sender}', subject='{self.subject}', "
                f"time_sent='{self.time_sent}')")


# Much of the code below was derived from
# https://thepythoncode.com/article/reading-emails-in-python?utm_content=cmp-true
def try_decode(data: bytes, encoding: str) -> str:
    """ Attempts to call decode on the item provided, and decode it according to the encoding provided.

    :param data: the data to decode.
    :param encoding: the encoding to decode with.
    :return: the encoded data if decoding was successful; if there was a problem, the provided data is returned.
    """
    try:
        # The encoding is sometimes None when it should be a string
        if isinstance(data, bytes) and isinstance(encoding, str):
            # if it's a bytes, decode to str
            data = data.decode(encoding)
    except:
        data = str(data)

    return data


def get_subject(msg: Message) -> str:
    """ Gets the subject of an email Message """
    # decode the email subject
    subject, encoding = decode_header(msg["Subject"])[0]

    subject = try_decode(subject, encoding)

    return subject


def get_sender(msg: Message) -> str:
    """ Gets the sender name and email address of an email Message """
    # decode email sender
    sender, encoding = decode_header(msg["From"])[0]
    sender = try_decode(sender, encoding)

    return sender


def get_body(msg: Message) -> str:
    """ Gets the body of an email Message """

    body = ""
    # If the message is multipart, go through all the parts until something can be decoded.
    if msg.is_multipart():
        for part in msg.walk():
            try:
                body = part.get_payload(decode=True).decode()
                break
            except:
                pass
    else:
        body = msg.get_payload(decode=True).decode()

    return body


def get_sent_datetime(msg: Message) -> datetime:
    """ Gets the date and time an email Message was sent """
    # Date is in this format: Mon, 13 May 2024 13:33:47 +0000
    raw_date = str(msg["Date"])
    split_raw_date = raw_date.split(" ")[1:-1]  # ['13', 'May', '2024', '13:33:47']

    split_date = split_raw_date[:-1]  # Ignore time to just get date
    split_time = split_raw_date[-1].split(":")  # Split time

    sent_datetime = datetime(day=int(split_date[0]), month=month_name_to_number[split_date[1]], year=int(split_date[2]),
                             hour=int(split_time[0]), minute=int(split_time[1]), second=int(split_time[2]))

    return sent_datetime


def get_email_details(msg: Message, email_id: int) -> Email:
    """ Gets the sender, subject, content type, body, and datetime sent. Requires the email ID as a parameter,
    because any time this function is used, the ID will probably already have been retrieved. """
    return Email(email_id, get_sender(msg), get_subject(msg),
                 get_body(msg), get_sent_datetime(msg))


class EmailManager:
    """ Handles accessing the email account. """
    def __init__(self, username, password, imap_server):
        """ Creates an IMAP4_SSL object and logs into the email account. """
        self.imap = imaplib.IMAP4_SSL(imap_server)
        self.imap.login(username, password)

    def get_email(self, email_id: int) -> Email:
        """ Creates an Email object from an email ID - returns None on failure. """
        self.imap.select("INBOX")
        email_obj = None
        try:
            res, msg = self.imap.fetch(str(email_id), "(RFC822)")
            for response in msg:
                if isinstance(response, tuple):
                    # Parse a bytes email into a Message object
                    msg = email.message_from_bytes(response[1])

                    # Parse details about Message object into Email object
                    email_obj = get_email_details(msg, email_id)
        except Exception as e:
            print(e)  # TODO add logging

        self.close_mailbox()
        return email_obj

    def close_mailbox(self):
        """ Try to close any open mailbox. """
        try:
            self.imap.close()
        except Exception as e:
            print(f"Failed to close mailbox: {e}")  # TODO add logging

    def __del__(self):
        """ Try to log out. Often displays an error if not del-ed before the program ends. """
        try:
            self.imap.logout()
        except Exception as e:
            print(f"Logout failed: {e}")  # TODO add logging

    def get_tldr_emails(self) -> list[int]:
        """ Gets all the email IDs that were sent from TLDR. """
        self.imap.select("INBOX")

        # Get all IDs of emails from TLDR - imap.search returns a tuple containing a status and then the IDs
        email_ids_bytes_list = self.imap.search(None, '(FROM "dan@tldrnewsletter.com")')[1]
        # Email bytes list is of the form: [b'2 4 5 6 7'] - remove this from the list, and specify they are bytes to
        # help PyCharm.
        email_ids_bytes = bytes(email_ids_bytes_list[0])
        # Split the bytes by spaces, and use list comprehension to convert to list of integers.
        email_ids = [int(email_id) for email_id in email_ids_bytes.split(b" ")]

        self.close_mailbox()
        return email_ids
