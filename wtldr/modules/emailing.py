""" Contains functionality and classes related to getting emails from an email account.
Highlights:
The Email dataclass, for representing key information about emails. This dataclass also has static methods
    for decoding information from email messages.
The EmailManager class, for handling interactions with an email account.
"""

import email
import imaplib
import ssl
from dataclasses import dataclass
from datetime import datetime
from email.header import decode_header
from email.message import Message
from logging import Logger

# Dictionary generated by ChatGPT
month_name_to_number = {
    "January": 1,
    "February": 2,
    "March": 3,
    "April": 4,
    "May": 5,
    "June": 6,
    "July": 7,
    "August": 8,
    "September": 9,
    "October": 10,
    "November": 11,
    "December": 12
}


# For typing
class Email:
    pass


@dataclass
class Email:
    """ Dataclass for storing details about emails """
    email_id: int
    sender: str
    subject: str
    body: str
    time_sent: datetime

    def __repr__(self):
        return (f"Email(email_id={self.email_id}, sender='{self.sender}', subject='{self.subject}', "
                f"time_sent='{self.time_sent}')")

    # Much of the code below was derived from
    # https://thepythoncode.com/article/reading-emails-in-python?utm_content=cmp-true
    @staticmethod
    def try_decode(data: bytes, encoding: str) -> str:
        """ Attempts to call decode on the item provided, and decode it according to the encoding provided.

        :param data: the data to decode.
        :param encoding: the encoding to decode with.
        :return: the encoded data if decoding was successful; if there was a problem, the provided data is returned.
        """
        try:
            # The encoding is sometimes None when it should be a string
            if isinstance(data, bytes) and isinstance(encoding, str):
                # if it's a bytes, decode to str
                data = data.decode(encoding)
        except:
            data = str(data)

        return data

    @staticmethod
    def get_subject(msg: Message) -> str:
        """ Gets the subject of an email Message """
        # decode the email subject
        subject, encoding = decode_header(msg["Subject"])[0]

        subject = Email.try_decode(subject, encoding)

        return subject

    @staticmethod
    def get_sender(msg: Message) -> str:
        """ Gets the sender name and email address of an email Message """
        # decode email sender
        sender, encoding = decode_header(msg["From"])[0]
        sender = Email.try_decode(sender, encoding)

        return sender

    @staticmethod
    def get_body(msg: Message) -> str:
        """ Gets the body of an email Message """

        body = ""
        # If the message is multipart, go through all the parts until something can be decoded.
        if msg.is_multipart():
            for part in msg.walk():
                try:
                    body = part.get_payload(decode=True).decode()
                    break
                except:
                    pass
        else:
            body = msg.get_payload(decode=True).decode()

        return body

    @staticmethod
    def get_sent_datetime(msg: Message) -> datetime:
        """ Gets the date and time an email Message was sent """
        # Date is in this format: Mon, 13 May 2024 13:33:47 +0000
        raw_date = str(msg["Date"])
        split_raw_date = raw_date.split(" ")[1:-1]  # ['13', 'May', '2024', '13:33:47']

        split_date = split_raw_date[:-1]  # Ignore time to just get date
        split_time = split_raw_date[-1].split(":")  # Split time

        sent_datetime = datetime(day=int(split_date[0]), month=month_name_to_number[split_date[1]],
                                 year=int(split_date[2]),
                                 hour=int(split_time[0]), minute=int(split_time[1]), second=int(split_time[2]))

        return sent_datetime

    @staticmethod
    def get_email_details(msg: Message, email_id: int) -> Email:
        """ Gets the sender, subject, content type, body, and datetime sent. Requires the email ID as a parameter,
        because any time this function is used, the ID will probably already have been retrieved. """
        return Email(email_id, Email.get_sender(msg), Email.get_subject(msg),
                     Email.get_body(msg), Email.get_sent_datetime(msg))


class EmailManager:
    """ Handles accessing the email account. Most methods of this class do not handle exceptions. """

    def __init__(self, username: str, password: str, imap_server: str, logger: Logger):
        """ Creates an IMAP4_SSL object and logs into the email account. Exceptions may be raised. """
        self.imap = imaplib.IMAP4_SSL(imap_server)
        self.imap.starttls(ssl_context=ssl.create_default_context())
        self.imap.login(username, password)

        self.logger = logger

    def get_email(self, email_id: int, mailbox="INBOX") -> Email:
        """ Creates an Email object from an email ID - may return None on failure. May raise exceptions. """
        self.imap.select(mailbox)
        email_obj = None

        res, msg = self.imap.fetch(str(email_id), "(RFC822)")
        for response in msg:
            if isinstance(response, tuple):
                # Parse a bytes email into a Message object
                msg = email.message_from_bytes(response[1])

                # Parse details about Message object into Email object
                email_obj = Email.get_email_details(msg, email_id)

        self.close_mailbox()
        return email_obj

    def close_mailbox(self):
        """ Try to close any open mailbox. Logs the exception on failure. """
        try:
            self.imap.close()
        except Exception as e:
            self.logger.error(f"Failed to close mailbox: {e}")

    def __del__(self):
        """ Try to log out. Often displays an error if not deleted before the program ends; if this occurs, delete this instance at the end of the program. """
        try:
            self.imap.logout()
        except Exception as e:
            self.logger.error(f"Logout failed: {e}")

    def get_tldr_emails(self) -> list[int]:
        """ Gets all the email IDs that were sent from TLDR. """
        self.imap.select("INBOX")

        # Get all IDs of emails from TLDR - imap.search returns a tuple containing a status and then the IDs
        email_ids_bytes_list = self.imap.search(None, '(FROM "dan@tldrnewsletter.com")')[1]
        # Email bytes list is of the form: [b'2 4 5 6 7'] - remove this from the list, and specify they are bytes to
        # help PyCharm.
        email_ids_bytes = bytes(email_ids_bytes_list[0])
        # Split the bytes by spaces, and use list comprehension to convert to list of integers.
        email_ids = [int(email_id) for email_id in email_ids_bytes.split(b" ")]

        self.close_mailbox()
        return email_ids
